
# PRD.md: 비디오 화자 분리 및 자막 교정 자동화 시스템 (AMD/ROCm 기반)

## 1. 개요 (Introduction)

본 프로젝트는 **Docker 기반 n8n**을 사용하여 비디오 파일에서 **화자 분리(RX 9060 XT/ROCm 활용)**, **자막 추출 및 LLM 교정(Gemini)**, **화자별 음성 생성**까지의 과정을 자동화합니다. 핵심 모듈은 로컬 GPU 자원을 활용하여 성능을 극대화하는 것에 중점을 둡니다.

### 1.1. 프로젝트 목표

* **GPU 가속:** AMD Radeon RX 9060 XT의 **ROCm** 스택을 활용하여 diarization_module의 성능을 최적화.
* **환경 일관성:** n8n은 Docker로 격리하여 관리 편의성을 높이고, Python 모듈은 로컬 호스트에서 실행하여 GPU 자원에 직접 접근.
* **자막 품질:** Gemini LLM을 통한 정교한 교정으로 최종 자막 및 음성 파일의 품질 보장.

## 2. 시스템 구성 및 아키텍처

### 2.1. 인프라 아키텍처

| 구성 요소 | 기술/도구 | 환경/특징 | 역할 |
| :--- | :--- | :--- | :--- |
| **워크플로우 엔진** | **n8n** | **Docker Container** (Port 5678) | 파이프라인의 실행 및 모듈 간 데이터 흐름 제어. |
| **GPU/코드 실행** | **Local Python** | **AMD Radeon RX 9060 XT, ROCm** | GPU 집약적인 P.1 모듈 및 모든 Python 모듈 실행. |
| **GPU 드라이버** | **ROCm** | Local OS (Linux 권장) | AMD GPU를 위한 병렬 컴퓨팅 프레임워크 제공 (CUDA 대체). |
| **LLM 서비스** | **Gemini API** | 클라우드 서비스 | 자막의 문법적, 내용적 오류 교정. |

### 2.2. 데이터 흐름 및 모듈

| 모듈 ID | 모듈명 | 주요 기능 | 입/출력 파일 |
| :--- | :--- | :--- | :--- |
| **P.1** | diarization_module | **RX 9060 XT/ROCm**을 이용한 화자 분리 및 **source.srt** 추출. | 입력: .mp4 / 출력: source.srt |
| **P.2** | llm_correction_module | LLM(Gemini)을 통한 자막 교정 및 **cleaned.srt** 생성. | 입력: source.srt / 출력: cleaned.srt |
| **P.3** | tts_module | **Chatterbox**를 이용한 화자별 음성 파일 생성. | 입력: cleaned.srt / 출력: .mp3 또는 .wav 파일 |

---

## 3. 세부 요구사항 (Detailed Requirements)

### 3.1. 인프라 및 n8n 워크플로우 (Task 1)

| ID | 요구사항 | 상세 설명 |
| :--- | :--- | :--- |
| **D.1.1** | **Docker Compose 설정** | n8n 컨테이너 실행을 위해 docker-compose.yml을 작성하며, **로컬 파이썬 모듈 접근을 위한 네트워크 및 권한 설정**을 포함합니다. |
| **D.1.2** | **볼륨 마운트** | n8n 컨테이너가 로컬 호스트의 **입/출력 데이터 폴더 및 Python 스크립트 폴더**에 접근할 수 있도록 볼륨을 명확하게 마운트해야 합니다. (예: -v /path/to/project:/usr/src/app/data) |
| **D.1.3** | **Execute Command** | n8n 워크플로우는 Execute Command 노드를 사용하여 로컬 호스트의 Python 환경을 호출하며, **GPU 경로/권한 관련 환경 변수**를 전달할 수 있도록 준비합니다. |
| **D.1.4** | **API 키 보안** | Gemini API 키는 n8n의 **Secret (Credentials)** 기능으로 관리되며, 스크립트 실행 시 보안을 유지하며 인수로 전달됩니다. |

### 3.2. 모듈 1: 화자 분리 및 자막 추출 (diarization_module)

| ID | 요구사항 | 상세 설명 |
| :--- | :--- | :--- |
| **P.1.1** | **AMD GPU 지원 구현** | whisper-diarization 로직에서 GPU를 사용하도록 구성할 때, **CUDA가 아닌 ROCm 기반의 PyTorch 또는 관련 라이브러리**를 사용하도록 설정해야 합니다. |
| **P.1.2** | **ROCm 호환성** | **ROCm Compatibility Matrix**를 확인하여 사용하는 PyTorch 버전 및 기타 AI 라이브러리가 **RX 9060 XT**를 지원하는지 검증해야 합니다. (ROCm 설정이 로컬 OS에 선행되어야 함) |
| **P.1.3** | **성능 검증** | 모듈 실행 시 **GPU 사용률**을 확인하여 실제로 RX 9060 XT가 병렬 연산에 활용되고 있는지 검증해야 합니다. |
| **P.1.4** | **출력 형식** | 최종 .srt 파일은 **[Speaker X]: [대사 내용]** 형식을 엄격하게 준수해야 합니다. |

### 3.3. 모듈 2: LLM 자막 교정 (llm_correction_module)

| ID | 요구사항 | 상세 설명 |
| :--- | :--- | :--- |
| **P.2.1** | **프롬프트 전략** | Gemini에게 자막 교정을 요청할 때, **타임스탬프와 화자 태그를 원본 그대로 유지**하라는 강력한 제약 조건을 포함한 프롬프트를 사용합니다. |
| **P.2.2** | **.srt 파싱/재조립** | Python 코드가 .srt 파일을 읽어 **텍스트 내용 부분만 추출**하여 LLM에 전달하고, LLM의 교정된 텍스트를 다시 **정확한 타임라인에 삽입**하여 cleaned.srt를 생성해야 합니다. |

### 3.4. 모듈 3: 화자별 음성 생성 (tts_module)

| ID | 요구사항 | 상세 설명 |
| :--- | :--- | :--- |
| **P.3.1** | **화자별 목소리 매핑** | [Speaker 1], [Speaker 2] 등 화자 태그를 기반으로 Chatterbox에서 제공하는 **서로 다른 목소리 ID**를 동적으로 할당해야 합니다. |
| **P.3.2** | **타임라인 기반 생성** | 자막의 타임스탬프를 활용하여 생성된 오디오 클립들을 정확한 순서와 시간 간격으로 병합하여 최종 오디오 파일의 싱크를 맞춥니다. |

## 4. 작업 관리 및 테스트 (Claude Task Manager)

| Task ID | 담당 모듈 | 작업 내용 | 검증 기준 (Done Criteria) |
| :--- | :--- | :--- | :--- |
| **T.1** | 인프라 | **Docker Compose**를 이용한 n8n 및 로컬 호스트 간 파일/명령어 연동 설정 완료. | n8n에서 로컬 Python 스크립트 호출 성공 확인. |
| **T.2** | P.1 | **ROCm** 환경에서 diarization_module 구현 및 **RX 9060 XT GPU 활용** 검증. | 파이프라인 실행 중 rocm-smi 등으로 GPU 사용률 측정. |
| **T.3** | P.2 | LLM 교정 모듈 구현 및 **화자 태그/타임스탬프 무결성** 테스트. | 교정 전후 .srt 파일 비교 시, 텍스트 외 정보가 일치함 확인. |
| **T.4** | P.3 | TTS 모듈 구현 및 **화자별 음성 분리** 로직 적용. | 최종 오디오 파일에서 화자 전환 시 목소리가 명확히 바뀜 확인. |
| **T.5** | n8n | P.1 → P.2 → P.3을 연결하는 최종 워크플로우 구성 및 전체 자동화 테스트. | 비디오 입력 시 최종 음성 파일까지 **오류 없이** 자동 생성 완료. |